<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - glTF loader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>

	<body>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.5.1/gsap.min.js"></script>
        
        <div id="info">
            <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - Pinball physics<br />
            Space - launch ball, z - left flipper, / - right flipper
        </div>

        <script type="module">

            import * as THREE from '../build/three.module.js';
            import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
            import { GUI } from './jsm/libs/dat.gui.module.js';
            import Stats from './jsm/libs/stats.module.js';
            import { OrbitControls } from './jsm/controls/OrbitControls.js';
            import { BufferGeometryUtils } from './jsm/utils/BufferGeometryUtils.js';
            import '../build/cannon.js';

            let camera, scene, renderer, world, mass, body, shape, geometry, material, mesh, flipperleft, flipperright, field, bumperleft, bumperright, object;
            
            const timeStep = 1/60;

            const manager = new THREE.LoadingManager();
            
            let loadingDone = false;
            
            let loaded = {};
            
            let balls = {};
            let ballscount = 0;
            let balllaunched = true;
            
            let bodies = {}
            
            const cannonMaterials = {};
            
            cannonMaterials["mat"] = new CANNON.Material();
            cannonMaterials["groundMaterial"] = new CANNON.Material();
            cannonMaterials["bumperMaterial"] = new CANNON.Material();
            cannonMaterials["slingshotMaterial"] = new CANNON.Material();
            
            const mat_ground = new CANNON.ContactMaterial(cannonMaterials["groundMaterial"], cannonMaterials["mat"], { friction: 0.0, restitution: 0.2 });
            const mat_bumper = new CANNON.ContactMaterial(cannonMaterials["bumperMaterial"], cannonMaterials["mat"], { friction: 0.0, restitution: 1.5 });
            const mat_slingshot = new CANNON.ContactMaterial(cannonMaterials["slingshotMaterial"], cannonMaterials["mat"], { friction: 0.0, restitution: 1.5 });
            
            const matStdObjects = new THREE.MeshLambertMaterial({color: 0xffffff});
            
            const response = await fetch('gltflist.json');
            const data = await response.text();
            let gltflist = JSON.parse(data);
            
            let models = {};

			init();
            initCannon();
            
            function initCannon() {
                
                const radius = 0.5; // m
                const damping = 0.01;

                world = new CANNON.World();
                world.gravity.set(0, -30, 9.82); // m/sÂ²
                world.broadphase = new CANNON.NaiveBroadphase();
                //world.solver.iterations = 10;

                shape = new CANNON.Sphere(radius);
                mass = 1;
                body = new CANNON.Body({
                    mass: 5,
                    material: cannonMaterials["mat"],
                    position: new CANNON.Vec3(9.25, 0, 0) // m
                });
                
                body.addShape(shape);
                body.linearDamping = damping;
                body.velocity.set(0,0,0);
                world.addBody(body);
                
                // Create a plane
                const groundBody = new CANNON.Body({
                    mass: 0,
                    material: cannonMaterials["groundMaterial"] // mass == 0 makes the body static
                });
                const groundShape = new CANNON.Plane();
                groundBody.addShape(groundShape);
                //world.addBody(groundBody);
                
                world.addContactMaterial(mat_ground);
                world.addContactMaterial(mat_bumper);
                
                createBall();
                animate();

            }

            function init() {

                const container = document.createElement( 'div' );
                document.body.appendChild( container );

                camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
                camera.position.set( 0, 30, 10 );

                scene = new THREE.Scene();
                scene.background = new THREE.Color( 0xffffff );
                
                const light = new THREE.AmbientLight( 0x404040 ); // soft white light
                //scene.add( light );
                
                const spotLight = new THREE.SpotLight( 0xffffff,1 );
                spotLight.position.set( 0, 20, -50 );
                scene.add( spotLight );
                
                checkLoaded();
                
                Object.keys(gltflist).forEach(key => {                   
                    loaded[key] = new loadmodel(gltflist[key].modelpath, gltflist[key].modelfile, gltflist[key].size, gltflist[key].smooth, key, gltflist[key].posx, gltflist[key].posy, gltflist[key].posz, gltflist[key].meshmat);
                });

                renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1;
                renderer.outputEncoding = THREE.sRGBEncoding;
                container.appendChild( renderer.domElement );

                const controls = new OrbitControls( camera, renderer.domElement );
                controls.addEventListener( 'change', render ); // use if there is no animation loop
                controls.minDistance = 2;
                controls.maxDistance = 40;
                controls.target.set( 0, 0, 0 );
                controls.update();

				window.addEventListener( 'resize', onWindowResize );
                window.addEventListener("keydown", event => {
                    //console.log(event.keyCode);
                    if (event.isComposing || event.keyCode === 90) {
                        console.log("z");
                        gsap.to(qrotleft.rotation, 0.1, {y: 45, ease:Linear.easeNone});
                    }
                    if (event.isComposing || event.keyCode === 191) {
                        console.log("/");
                        gsap.to(qrotright.rotation, 0.1, {y: 135,  ease:Linear.easeNone});
                    }
                    if (event.isComposing || event.keyCode === 32) {
                        console.log("space");
                        if (balllaunched == false) {
                            body.velocity.set(0,0,-27.5);
                            balllaunched = true;
                        }
                        
                        //gsap.to(launcher.position, 0.5, {y:15 ,  ease:Linear.easeNone});
                    }
                    
                });
                window.addEventListener("keyup", event => {
                    //console.log(event.keyCode);
                    if (event.isComposing || event.keyCode === 90) {
                        console.log("z");
                        gsap.to(qrotleft.rotation, 0.2, {y: -45, ease:Linear.easeNone});
                    }
                    if (event.isComposing || event.keyCode === 191) {
                        console.log("/");
                        gsap.to(qrotright.rotation, 0.2, {y: 225,  ease:Linear.easeNone});
                    }
//                    if (event.isComposing || event.keyCode === 32) {
//                        console.log("space");
//                        //gsap.to(launcher.position, 0.2, {y: 19,  ease:Linear.easeNone});
//                    }
                });
                
                //console.log(loaded);

			}
            
            function loadmodel(modelpath, modelfile, meshsize, smooth, scenekey, posx, posy, posz, meshmat) {
                
                this.smooth = smooth;
                
                this.loader = new GLTFLoader(manager).setPath(modelpath);
                this.loader.load( modelfile, function ( gltf ) {
                    
                    this.gltf = gltf;
                    
                    //For wireframe look
//                     this.gltf.scene.traverse((node) => {
//                        if (!node.isMesh) return;
//                        node.material.wireframe = true;
//                    });

                    this.gltf.scene.traverse( function ( child ) {
                        if ( child.isMesh ) {
                            child.material = matStdObjects;
                            child.castShadow = true;
				            child.receiveShadow = true;
                            child.doubleSided = false;
                        }
                    });

                    this.gltf.scene

//                    if(this.smooth == 1) {
//                        setSmoothGeometry(this.gltf.scene);
//                    }
//
//                    function setSmoothGeometry(obj) {
//                        obj.traverse(node => {
//                            if ('geometry' in node) {
//                                const tempGeometry = new THREE.Geometry().fromBufferGeometry( node.geometry );
//                                tempGeometry.mergeVertices();
//                                tempGeometry.computeVertexNormals();
//                                node.geometry = new THREE.BufferGeometry().fromGeometry( tempGeometry );
//                            }
//                        })
//                    }
                    
                   
                    let glTFGeometry;
                    
                    let scale;
                    
                    // Might be used someday, have to look into bufferGeometry
                    //let glTFGeometry = new THREE.BufferGeometry();
                    
                    this.gltf.scene.traverse( function ( child ) {

                        if ( child.isMesh ) {
                            //child.material.envMap = envMap;
                            //Setting the buffer geometry
                            //glTFGeometry = child.geometry;
                            glTFGeometry = new THREE.Geometry().fromBufferGeometry(child.geometry);
                            //console.log(glTFGeometry);
                            scale = child.scale;
                        }

                    } );
                    
                    

                    let vertices = [], faces = [];

                    // Add vertices
                    for (let i = 0; i < glTFGeometry.vertices.length; i++) {

                        let x = scale.x * glTFGeometry.vertices[i].x;
                        let y = scale.y * glTFGeometry.vertices[i].y;
                        let z = scale.z * glTFGeometry.vertices[i].z;

                        vertices.push(new CANNON.Vec3(x, y, z));
                    }

                    for (let i = 0; i < glTFGeometry.faces.length; i++) {

                        let a = glTFGeometry.faces[i].a;
                        let b = glTFGeometry.faces[i].b;
                        let c = glTFGeometry.faces[i].c;

                        faces.push([a, b, c]);
                    }
                    
                    shape = new CANNON.ConvexPolyhedron(vertices, faces);
                    
//                    
                    let gltfBody = new CANNON.Body({
                        mass: 0, // mass == 0 makes the body static
                        material: cannonMaterials[meshmat],
                        position: new CANNON.Vec3(posx, posy, posz) // m
                    });
//                    const groundShape = new CANNON.Plane();
//                    console.log(glTFGeometry);
//                    console.log(groundShape);
                    const gltfShape = glTFGeometry;
                    gltfBody.addShape(shape);
                    
                    bodies[scenekey] = gltfBody;
                    
                    
                    this.gltf.scene.castShadow = true;
				    this.gltf.scene.receiveShadow = true;

//                   this.gltf.scene.scale.set( meshsize, meshsize, meshsize )
                    positionObject(this.gltf.scene, gltflist[scenekey].posx, gltflist[scenekey].posy, gltflist[scenekey].posz);
                    scene.add( this.gltf.scene );
                    
                    this.gltf.scene.position.copy(gltfBody.position);
                    this.gltf.scene.quaternion.copy(gltfBody.quaternion);
                    world.addBody(bodies[scenekey]);
                    
                }.bind(this));
            }
            
            //Check if assets loaded
            function checkLoaded() {
                manager.onStart = function ( url, itemsLoaded, itemsTotal ) {
                    console.log( 'Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
                };

                manager.onLoad = function ( ) {
                    console.log( 'Loading complete!');
                    loadingDone = true;
                };

                manager.onProgress = function ( url, itemsLoaded, itemsTotal ) {
                    console.log( 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
                };

                manager.onError = function ( url ) {
                    console.log( 'There was an error loading ' + url );
                };
            }
            
            //Set position object
            function positionObject(object, posX=0, posY=0, posZ=0) {
                object.translateX(posX);
                object.translateY(posY);
                object.translateZ(posZ);
            }
            
            //Create ball
            function createBall() {
                const geometry = new THREE.SphereGeometry( 0.5, 32, 32 );
                const material = new THREE.MeshStandardMaterial( { color: 0xffffff, roughness: 0.14, metalness: 1 } );
                const sphere = new THREE.Mesh( geometry, material );
//                sphere.translateX(posX);
//                sphere.translateY(posY);
//                sphere.translateZ(-13);
                scene.add( sphere );
                balls[ballscount] = sphere; 
                ballscount++;
//                console.log(balls);
                body.addEventListener("collide",function(e){
//                  console.log("The sphere just collided with the ground!");
//                  console.log("Collided with body:",e.body);
//                  console.log("Contact between bodies:",e.contact);
                    
                    if (e.body.id == "2") {
                        balllaunched = false;
                    }
                });
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
                render();
            }
            
            let qrotleft = {
                rotation: {
                    y: -45
                }
            };
            
            let qrotright = {
                rotation: {
                    y: 225
                }
            };
            
            let launcher = {
                position: {
                    y: 19
                }
            };

            function updatePhysics() {

                // Step the physics world
                world.step(timeStep);

                // Copy coordinates from Cannon.js to Three.js
                balls[0].position.copy(body.position);
                balls[0].quaternion.copy(body.quaternion);
                
                //console.log(bodies);
                if(loadingDone) {
                    let qrotdegleft = THREE.Math.degToRad(qrotleft.rotation.y);
                    let qrotdegright = THREE.Math.degToRad(qrotright.rotation.y);
                    loaded.c.gltf.scene.quaternion.setFromAxisAngle(new THREE.Vector3(0,1,0),qrotdegleft);
                    bodies.c.quaternion.setFromAxisAngle(new THREE.Vector3(0,1,0),qrotdegleft);
                    loaded.h.gltf.scene.quaternion.setFromAxisAngle(new THREE.Vector3(0,1,0),qrotdegright);
                    bodies.h.quaternion.setFromAxisAngle(new THREE.Vector3(0,1,0),qrotdegright);
                    loaded.a.gltf.scene.position.z = launcher.position.y;
                    bodies.a.position.z = launcher.position.y;
                }

            }
            
            function animate() {
                requestAnimationFrame( animate );
                updatePhysics();
                render();
            }

			function render() {
				renderer.render( scene, camera );
			}

		</script>

	</body>
</html>